'''-테트리스처럼 한번에 처리 가능한 묶음을 k초에서 한번에 빼면서 계산하는 과정에서 heapq를 사용하면 시간 초과 문제를 해결가능함.
   
<1단계>
*
*     *
*  *  *
1 2  3 

k = 5
q = [[3, 1], [1, 2], [2, 3]]
-[a, b]의 형태로 q 리스트에 저장을 하는데 이때 a는 남은 음식의 시간(초마다 줄어듬), b는 해당 음식의 번호(불변)를 의미한다.
-이 단계에서 가장 작은 음식의 번호는 2번이고 음식의 양은 1이기 때문에 한번에 처리 가능한 최대 초는 1 * (q의 길이) = 3초가 된다
-따라서 두번째 음식은 다 먹었으니 리스트에서 삭제하고 남은 초는 k=5초에서 3초를 뺀 k=2초가 된다.

<2단계>
*
* *
1 3

k = 2
q = [[2, 1], [1, 3]]
- (가장 적게 남은 음식의 시간 : 1) * (총 길이: 2) = 2
- 남은 초 k - 2 = 0초

<3단계>
*
1

k = 0
-k가 0인 순간에 먹어야 할 음식은 1번 음식이 된다. 

ex2)
food_times = [8, 6, 4]
k = 15

<1단계>
*
*
*  *
*  *
*  *  *
*  *  *
*  *  *
*  *  *
1  2  3

k = 15
q = [[8, 1], [6, 2], [4, 3]]
- (가장 적게 남은 음식의 시간 : 4) * (총 길이 : 3) = 12초
- 남은 초 k - 12 = 3초

<2단계>
*
*
*  *
*  *
1  2

k = 3
q = [[4, 1], [2, 2]]
- (가장 적게 남은 음식의 시간 : 2) * (총 길이 : 2) = 4초
- 남은 초 k - 4 = -1초인데 음수이기 때문에 더이상 한번에 처리 불가능하고 초 하나하나 세어가면서 k가 0초가 되는 순간에 먹어야할 음식을 구한다.
- 즉 q를 음식 번호 순서대로 나열하여 하나하나 세어봐야 하는데 이때 q를 다시 정렬하려면 q.sort(key = lambda x : x[1])를 하면 된다.
- k = 3일 때 1번 음식
- k = 2일 때 2번 음식
- k = 1일 때 1번 음식
- k = 0일 때 2번 음식
-여기서 규칙을 보면 k=0일 때 먹어야 하는 음식의 번호는 k%(음식의 총 길이) + 1, 즉 q[k%len(q)][1] 이라는 것을 알 수 있다.
-따라서 정답은 3 % 2 + 1 = 2 이다.'''
import heapq

def solution(food_times, k):
    if sum(food_times) <= k:
        return -1
    else:
        q = []
        for i in range(len(food_times)):
            heapq.heappush(q, [food_times[i], i+1])
        
        length = len(data)
        
        while length * q[0][0] <= k: #남은 시간이 (배열의 길이 * 가장 적게 남은 음식) 보다 크거나 같아야함.
            min_value = heapq.heappop(data)[0]
            for i in range(len(data)):#돌아가면서 동일 최소값 빼기
                q[i][0] -= min_value
            k -= length * min_value#현재 남은 시간에서 (배열의 길이 * 가장 적게 남은 음식)을 빼준다
            length -= 1

        q.sort(key=lambda x: x[1])
        result = q[k%length][1]
        return result

